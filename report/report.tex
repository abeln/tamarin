\documentclass{llncs}

\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{mips}
\usepackage{amsmath}
\usepackage{cancel}
\usepackage{tikz}
\usepackage{url}
\usetikzlibrary{shapes,backgrounds,arrows, fit, positioning}
\usepackage{algpseudocode}

\newcommand{\crule}[3][black]{\textcolor{#1}{\rule{#2}{#3}}}

\newcommand{\erel}{\textsf{equiv}}
\newcommand{\merel}[1]{\textsf{equiv}_{#1}}
\newcommand{\pequiv}[2]{#1 \ \erel \ #2}
\newcommand{\pmequiv}[3]{#1 \ \merel{#3} \ #2}
\newcommand{\pnequiv}[2]{#1 \ \cancel{\erel} \ #2}
\newcommand{\pnmequiv}[3]{#1 \ \cancel{\merel{#3}} \ #2}

\definecolor{CommentGreen}{rgb}{0,.6,0}
\lstset{
 language=[mips]Assembler,
 escapechar=@, % include LaTeX code between `@' characters
 keepspaces,   % needed to preserve spacing with lstinline
 basicstyle=\footnotesize\ttfamily\bfseries,
 commentstyle=\color{CommentGreen},
 stringstyle=\color{cyan},
 showstringspaces=false,
 keywordstyle=[1]\color{blue},    % instructions
 keywordstyle=[2]\color{magenta}, % directives
 keywordstyle=[3]\color{red},     % registers
 }
 
\lstset{language=[mips]Assembler}

\title{Tamarin: Concolic Disequivalence for MIPS}
\author{Abel Nieto}
\institute{
University of Waterloo\\
\email{anietoro@uwaterloo.ca}
}

\begin{document}

\maketitle

\begin{abstract}
TODO
\end{abstract}

\section{Introduction}

We are staring at two opaque black boxes laying at our feet. Each box has a narrow slot through which we can place items in the box, but we cannot quite see what is inside. They look approximately like this:

\vspace{1mm}
\crule{1.5cm}{1.5cm}, \crule{1.5cm}{1.5cm}
\vspace{1mm}

We know each box contains an animal, but we do not know which specific animal is in each one. We would like to find out if both boxes contain the same species of animal. Our solution is simple: we take two carrots, and drop one in each box through the slots.

After a while, a chewing sound emerges from the boxes. We peer into them and, indeed, it looks like the carrots were successfully eaten. Triumphantly, we declare that the boxes contain the same species of animal. The truth is altogether different:

\vspace{1mm}
\fbox{\includegraphics[width=1.5cm]{camel}}, \fbox{\includegraphics[width=1.5cm]{beaver}}
\vspace{1mm}

The boxes are assembly programs. The animals are the functions those programs compute. The carrot is unit testing. The task was to determine whether the programs were equivalent. And we failed at it. In this paper, we show a technique that is better than the carrot.

Program equivalence. The program is the specification. The complications of assembly language.

\section{Program Equivalence for MIPS}

Let us set up the problem a bit more formally. Consider the set $P$ of MIPS-assembly programs that satisfy two restrictions: they take as inputs only the values of registers $\$1$ and $\$2$, and when they stop executing we define their output to be (exclusively) the value of $\$3$. Other side effects, such as printing values to the screen, or system calls, are disallowed.

We can now define a relation $\erel \subseteq P \times P$ (and its complement, $\cancel{\erel}$) of equivalent programs. Given $P_1, P_2 \in P$, we say that $\pequiv{P_1}{P_2}$ (read ``$P_1$ is equivalent to $P_2$'') if, for all inputs $\$1$ and $\$2$, one of the following holds:
\begin{itemize}
\item Both $P_1$ and $P_2$ fail during execution (for example, due to a divide-by-zero error).
\item $P_1$ and $P_2$ stop with the same output in $\$3$. 
\end{itemize} 

For example, the two programs in Figure \ref{equivprogs} are equivalent.
 
\begin{figure}
\begin{multicols}{2}
\begin{lstlisting}[escapeinside={(*}{*)}]
# P_1
add $3, $1, $2
\end{lstlisting}
\vfill\null
\columnbreak
\begin{lstlisting}
# P_2
add $4, $1, $1
lis $5
42
sw $4, 0, $5
add $3, $1, $2
\end{lstlisting}
\end{multicols}
\caption{$\pequiv{P_1}{P_2}$}
\label{equivprogs}
\end{figure}

Notice that $\pequiv{P_1}{P_2}$ even though $P_2$ modifies the contents of the memory and an additional register ($\$4$), because:
\begin{itemize}
\item Both $P_1$ and $P_2$ terminate without errors.
\item The value of $\$3$ will be the same when they do so.
\end{itemize}

Unfortunately, even though $\erel$ captures an already-simplified notion of equivalence\footnote{For example, $\erel$ has a very narrow notion of output that excludes side effects.}, a decision procedure for it does not exist, due to Rice's theorem.

To get decidability back, we define a new class of relations $\merel{S} \subseteq P \times P$ (whose complement is $\cancel{\merel{S}}$). We say that $\pmequiv{P_1}{P_2}{S}$ (read ``$P_1$ is $S$-equivalent to $P_2$'') if, for all inputs, one of the following holds:
\begin{itemize}
\item Either $P_1$ or $P_2$ does not stop within $S$ steps (we can think of each CPU cycle as one step).
\item Both $P_1$ and $P_2$ fail.
\item Both $P_1$ and $P_2$ stop with the same output. 
\end{itemize}

The $\merel{S}$ relation captures the notion that we cannot tell $P_1$ and $P_2$ apart by running them for at most $S$ steps. Figure \ref{sequiv} shows an example of two programs that are $S$-equivalent for $S=10$, but not equivalent. This is the case because $P_2$ loops while the counter is less than $42$, so with 10 steps in our ``budget'' we will have to stop $P_2$ before the loop is over and we can observe the different result.

\begin{figure}
\begin{multicols}{2}
\begin{lstlisting}[escapeinside={(*}{*)}]
# P_1
add $3, $1, $2
\end{lstlisting}
\vfill\null
\columnbreak
\begin{lstlisting}
# P_2
  add $4, $0, 1  # counter
  add $5, $0, 42 # upper bound
loop:
  slt $6, $4, $5 
  beq $6, $0, end
  add $4, $4, 1
  beq $0, $0, loop
end:
  add $3, $1, $1  
\end{lstlisting}
\end{multicols}
\caption{$\pmequiv{P_1}{P_2}{10}$, but $\pnequiv{P_1}{P_2}$}.
\label{sequiv}
\end{figure}

Given a fixed $S$, the $\merel{S}$ relation is decidable because there is a finite number of inputs to try, and for each input we only need to run the programs a finite number of steps.

We already saw that equivalence not always implies $S$-equivalence. However, the converse always holds. The following lemma shows that $\merel{S}$ over-approximates $\erel$.

\begin{lemma}
\label{overapprox}
$\forall S, P_1, P_2$, $\pequiv{P_1}{P_2} \implies \pmequiv{P_1}{P_2}{S}$.
\end{lemma}

\begin{proof}
Let $\pequiv{P_1}{P_2}$. Then we have one of two cases:
\begin{itemize}
\item Either $P_1$ or $P_2$ (or both) do not stop within S steps. Then by definition $\pmequiv{P_1}{P_2}{S}$.
\item Both $P_1$ and $P_2$ stop within S steps. Then because they are equivalent, we know that they either fail with an error, or both stop with the same output. In either case, $\pmequiv{P_1}{P_2}{S}$.
\end{itemize}
\end{proof}

\begin{corollary}
\label{soundness}
$\pnmequiv{P_1}{P_2}{S} \implies \pnequiv{P_1}{P_2}$. 
\end{corollary}

\begin{proof}
This is just the contrapositive of Lemma \ref{overapprox}.
\end{proof}

Corollary \ref{soundness} can be used to argue the soundness (with respect to $\cancel{\erel}$) of any decision procedure that under-approximates $\cancel{\merel{S}}$. In the next section we will show one such under-approximation based on concolic execution.

\section{Concolic Disequivalence}
\label{ideasection}

We know from Corollary \ref{soundness} that any relation that under-approximates $\cancel{\merel{S}}$ is sound. Figure \ref{hierarchy}  shows why want an under-approximation: efficiency. $\cancel{\erel}$ captures the class of programs that are disequivalent, but is undecidable. $\cancel{\merel{S}}$ is decidable, but likely cannot be computed efficiently. Therefore, we look for a subset of $\cancel{\merel{S}}$ (an under-approximation) that can be efficiently computed.

\begin{figure}
\def\firstcircle{(0,-1.8cm) circle (1.2cm)}
\def\secondcircle{(0,-1cm) circle (2cm)}
\def\thirdcircle{(0,0) circle (3cm)}
\begin{tikzpicture}
    \begin{scope}
        \draw[fill=green,opacity=0.1] \firstcircle;
        \draw[fill=yellow,opacity=0.1] \secondcircle;
        \draw[fill=red,opacity=0.1] \thirdcircle;
        \draw (0, -2) node  {??? (efficient)};
        \draw (0, 0) node {$\cancel{\merel{S}}$ (inefficient)};
        \draw (0, 2) node  {$\cancel{\erel}$ (undecidable)};
    \end{scope}
\end{tikzpicture}
\label{hierarchy}
\caption{Hierarchy of disequivalence relations}
\end{figure}

To fill the missing relation in Figure \ref{hierarchy} we propose concolic disequivalence. Abstractly, concolic disequivalence is a function $\textsf{compare}(P_1, P_2, S)$ that takes as inputs two MIPS programs and returns one of two answers:
\begin{itemize}
\item ``disequivalent'', in which case $\pnmequiv{P_1}{P_2}{S}$.
\item ``possibly equivalent'', meaning that $P_1$ and $P_2$ might or might not be $S$-equivalent.
\end{itemize}

Figure \ref{concolicalgo} shows pseudocode for \textsf{compare}. The algorithm alternately executes $P_1$ and $P_2$. At every step, one of the programs is labelled as the ``driver'' and the other one as the ``verifier''. The driver program is then concolically executed, yielding a set of inputs that exercise a new program path (of the driver). The inputs can then be fed to the verifier, and the results of both driver and verifier compared. If the results are different, then we know $P_1$ and $P_2$ are disequivalent. Otherwise, the driver becomes the verifier, and vice-versa. Eventually, we will traverse all explorable paths, at which point $P_1$ and $P_2$ can be declared possibly equivalent.

\begin{figure}
\begin{algorithmic}
\Function{compare}{$P_1$, $P_2$, $S$}
\State $b \gets true$
\While{either $P_1$ or $P_2$ has unexplored paths}
  \If{$b$} \Comment{Select driver and verifier}
    \State $D \gets P_1$
    \State $V \gets P_2$
  \Else
    \State $D \gets P_2$
    \State $V \gets P_1$
  \EndIf
  \If{$D$ has unexplored paths}
    \State $I \gets$ new inputs that exercise an unexplored path
    \State $R_1 \gets \textsf{run}(P_1, I, S)$
    \State $R_2 \gets \textsf{run}(P_2, I, S)$
    \If{both $P_1$ and $P_2$ stopped}
      \If{both $P_1$ and $P_2$ stopped with an error}
      \State \Comment{do nothing}
      \ElsIf{either $P_1$ or $P_2$ stopped with an error}
        \State \Return{``disequivalent''}
      \Else
        \If{$R_1 \neq R_2$}
          \State \Return{``disequivalent''}
        \EndIf
      \EndIf
    \EndIf
    \State mark the path discovered by $I$ as explored
    \State $b \gets \neg b$
  \EndIf
\EndWhile
\State \Return{``possibly equivalent''}
\EndFunction
\end{algorithmic}
\label{concolicalgo}
\caption{Concolic disequivalence algorithm}
\end{figure}

We now give an example of how \textsf{compare} operates. Consider the sample programs below:

\begin{multicols}{2}
\begin{lstlisting}[escapeinside={(*}{*)}]
# P_1
  bne $1, 42, end
  add $3, $0, $0
end:
  add $3, $1, $2
\end{lstlisting}
\vfill\null
\columnbreak
\begin{lstlisting}
# P_2
  add $3, $1, $2  
  bne $2, 100, end
  add $3, $3, $2
end:
\end{lstlisting}
\end{multicols}

Figure \ref{algoruns} summarizes the state of the algorithm as it compares $P_1$ and $P_2$. First, notice how the driver and verifier roles flip between $P_1$ and $P_2$ in consecutive runs. Every row indicates the input values, as well as the outputs $R_D$ and $R_V$ of the driver and verifier, respectively. At every run, we also record the path taken by the driver. Path conditions are negated to make sure we explore new paths in every iteration. In the fourth iteration, we can see of compare finds that the input pair $\$1 = 1, \$2 = 100$ leads to different outputs in the driver and verifier. At this point, $P_1$ and $P_2$ are declared as disequivalent. 

Notice that in order to uncover the different, it is necessary to concolically explore the paths in both $P_1$ and $P_2$, and not only of $P_1$. In Figure \ref{algoruns}, runs 1 and 3 explore both branches of the conditional jump in $P_1$, but they exercise the same path in $P_2$. Only after we also execute $P_2$ do we find a counterexample to equivalence.

\begin{figure}
\begin{tabular}{l | l | l | l | l | l | l | l}
Run & Driver & Verifier & $\$1$ & $\$2$ & Path & $R_D$ & $R_V$ \\
\hline 
1 & $P_1$ & $P_2$ & 1 & 1 & $\$1 \neq 42$ & 2 & 2 \\
2 & $P_2$ & $P_1$ & 1 & 1 & $\$2 \neq 100$ & 2 & 2\\
3 & $P_1$ & $P_2$ & 42 & 1 & $\$1 = 42$ & 2 & 2 \\
4 & $P_2$ & $P_1$ & 1 & 100 & $\$2 = 100$ & \textcolor{red}{201} & \textcolor{red}{2} 
\end{tabular}
\caption{A sample execution of \textsf{compare}}
\label{algoruns}
\end{figure}


\section{Tamarin}

Tamarin\footnote{Tamarins are small-sized monkeys from Central and South America. They are related to marmosets, which are also New World monkeys, and less-importantly give name to the black-box submission and testing server in use at the University of Waterloo as of Fall 2017 \cite{spacco2006marmoset}.} is a Scala implementation of the \textsf{compare} algorithm from Section \ref{ideasection}. We first give an overview of the major modules in Tamarin, shown in Figure \ref{tamarinstructure}, and then describe them in more detail in subsequent sections:

\begin{itemize}
\item \textsf{Concolic} is the entry point to Tamarin. It implements the top-level loop that visits unexplored paths, alternating between the two programs being compared. \textsf{Concolic} uses the other modules as helpers (in Figure \ref{tamarinstructure}, requests made by a module appear as solid lines, and responses to prior requests are shown with dashed lines).
\item \textsf{CPU} is a MIPS emulator that is instrumented to record symbolic traces containing path conditions, which can later be negated to explore new paths.
\item \textsf{Trace} consumes raw traces coming from \textsf{CPU} and transforms them in multiple ways so that they can be handed over to the \textsf{Z3} solver.
\item \textsf{Query} translates (modified) \textsf{CPU} traces into equivalent logical formulae. The formulae are then solved by the \textsf{Z3} solver, producing new inputs that, if fed to the program under test, will lead to traversing unexplored paths.
\item \textsf{Z3} is an SMT solver developed at Microsoft \cite{de2008z3}. We use it as black box for solving queries, over the theories of bitvectors and arrays, that result from program traces.
\end{itemize}

\begin{figure}
% Taken from http://www.texample.net/tikz/examples/simple-flow-chart/
% Define block styles
%\tikzstyle{decision} = [diamond, draw, fill=blue!20, 
%    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=3em]
    \tikzstyle{mainblock} = [rectangle, draw, fill=green!20, 
    text width=5em, text centered, rounded corners, minimum height=3em]
\tikzstyle{line} = [draw, -latex']
%\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
%    minimum height=2em]
    
\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [mainblock] (concolic) {Concolic};
    \node [block, left of=concolic, node distance=5cm] (cpu) {CPU};
    \node [block, above of=concolic, right of=concolic, node distance=3cm] (trace) {Trace};
    \node [block, below of=trace, right of=trace, node distance=3cm] (query) {Query};
    \node [block, fill=red!20, below of=query, node distance=3cm] (z3) {Z3};
    \node [draw=black, dashed, fit= (concolic) (cpu) (trace) (query)] {};
    \node at (-5.3, 3.3) {Tamarin};
    
%    % Draw edges
    \draw [line] (concolic) -- (cpu) node [midway, fill=white] {program};
%    \draw [-latex, bend left, dashed] (cpu) edge (concolic);
    \draw  (cpu)  edge [-latex, dashed, bend left=20] node[midway] {trace} (concolic);
    \draw [line] (concolic) -- (trace) node [midway]{trace};
    \draw [line] (trace) -- (query) node [midway]{modified trace};
    \draw [-latex, dashed] (query) -- (concolic) node [midway]{new path};
    \draw [line] (query) -- (z3) node [midway]{formula};
    \draw [-latex, dashed] (z3) edge [-latex, dashed, bend left=20] node[midway]{model} (query);
%    \path [line] (init) -- (identify);
%    \path [line] (identify) -- (evaluate);
%    \path [line] (evaluate) -- (decide);
%    \path [line] (decide) -| node [near start] {yes} (update);
%    \path [line] (update) |- (identify);
%    \path [line] (decide) -- node {no}(stop);
%    \path [line,dashed] (expert) -- (init);
%    \path [line,dashed] (system) -- (init);
%    \path [line,dashed] (system) |- (evaluate);
\end{tikzpicture}
\caption{Overview of Tamarin's modules}
\label{tamarinstructure}
\end{figure}

\subsection{Trace Collection}

The \textsf{CPU} module is in charge of running MIPS programs and collecting symbolic traces from executions. It is based on the MIPS emulator written by Ond\v{r}ej Lhot\'{a}k for CS241E at the University of Waterloo \cite{cs241e}.

The interface to the module consists of a single function:

\begin{lstlisting}[language=scala]
def run(prog: Seq[Word], r1: Word, r2: Word, fuel: Long): RunRes
\end{lstlisting}

The \textsf{run} function takes as input a program represented as as sequence of words, the values of registers $\$1$ and $\$2$ (the inputs to the program) and a \textsf{fuel} value (explained below).

The output is an algebraic data type \textsf{RunRes} that can take one of three forms:

\begin{lstlisting}[language=scala]
trait RunRes
case class Done(state: State, trace: Trace) extends RunRes
case class NotDone(trace: Trace) extends RunRes
case class Error(ex: RuntimeException) extends RunRes
\end{lstlisting}

\begin{itemize}
\item If the program executes without error, then \textsf{Done(state, trace)} is returned. \textsf{state} is the state of the CPU after execution, including the contents of memory (which are ignored) and of register $\$3$, the output register. \textsf{trace} is the symbolic trace captured during the program's execution, and is described below.
\item If the program ran for more than \textsf{fuel} CPU cycles without stopping, then the result is \textsf{NotDone(trace)}. Notice that even though the program did not stop we can still return a trace recording the execution right until the moment we stopped it. The \textsf{fuel} argument to \textsf{run} plays the same role as the $S$ argument in Figure \ref{concolicalgo}. 
\item Finally, if there was an error during program execution (for example, an attempted division-by-zero), then we return \textsf{Error}.
\end{itemize}

Notice that due to \textsf{fuel} parameter and error boxing, the augmented emulator in Tamarin, unlike a vanilla MIPS emulator, is ``hardened'' in the sense that it can execute MIPS programs that do not stop (the emulator itself will stop) or throw errors (will be catched at the top level by the emulator). 

While the emulator is executing a program, it also records a symbolic trace of (most of) the executed instructions. We support a subset of the MIPS instruction set, containing 18 instruction types \cite{mipsinstructions}. Notably, unlike in full MIPS, there are no system calls in our supported subset.

The fetch-decode-execute cycle in our emulator is modified to record a symbolic representation of each instruction as it is executed (Figure \ref{cpucycle}). The symbolic instructions are then stored in a trace. There are two types of instructions in a trace: assignments and path conditions.
\begin{itemize}
\item Assignments are instructions that mutate the CPU state, but do not affect the control flow. The symbolic form of most assignments is very similar to the concrete instruction that is executed. For example, the symbolic representation of the instruction \lstinline{add $3, $1, $2} is $r_3 \gets r_1 + r_2$. 

\item Path conditions are instructions that modify the control flow of the program. This set potentially contains both conditional and unconditional jumps, but we track only conditional ones. Specifically, we record the branch taken at each conditional jump, and symbolically record it as an (in)equality. For example, if the branch \lstinline{beq $1, $2, foolabel} is not taken, then we will add $r_1 \neq r_2$ to our trace.
\end{itemize}

\begin{figure}
\begin{tikzpicture}[node distance = 2cm, auto]
\node [draw] (fetch) {Fetch};
\node [draw, below of=fetch] (decode) {Decode};
\node [draw, below of=decode] (execute) {Execute};
\node [draw, right=2cm of decode] (symb) {MakeSymbolic};
\node [draw, right=2cm of symb, minimum height=4cm, text width=1.15cm] (trace) {};
\node [below right, text width=1cm] at (trace.north west) {Trace symb$_1$ symb$_2$ $\ldots$ symb$_{n - 1}$};

\draw [-latex] (fetch) -- (decode) node [midway] {word$_n$};
\draw [-latex] (decode) -- (execute) node [midway] {instr$_n$};
\draw [-latex, bend left=50] (execute) edge (fetch);
\draw [-latex] (decode) -- (symb) node [midway] {instr$_n$};
\draw [-latex] (symb) -- (trace) node [midway] {symb$_n$};
\end{tikzpicture}
\caption{Instrumented CPU that records symbolic traces}
\label{cpucycle}
\end{figure}

One additional point of note: the program counter (\textsf{pc}) is not symbolically tracked. This means Tamarin cannot reason about unconditional jumps, so only a single path is explored for the program in Figure \ref{pcnottrack}. There, Tamarin will execute $P$ with the initial inputs (a hard-coded constant) and error out, because the jump will lead to an invalid instruction. Tamarin will miss the fact that $\$1$ and $\$2$ can be given values such that we could jump to either of the labels, leading to a successful  execution. 

\begin{figure}
\begin{lstlisting}
# P
  add $4, $1, $2
  jr $4
good:
  add $3, $1, $2
  jr $31 # $31 contains the termination pc
bad:
  add $3, $1, $1
  jr $31    
\end{lstlisting} 
\caption{Not tracking the \textsf{pc} leads to under-approximations}
\label{pcnottrack}
\end{figure}

Since the \textsf{pc} is not tracked, whenever its value is used in another instruction, we need to substitute the \textsf{pc} by its concrete value. This technique is called concretization \cite{david2016specification}. For example, the load immediate and skip instruction has the following semantics:

\lstinline{lis $d} \hspace{5cm} $d \gets Mem[pc]; pc \gets pc + 4$



\subsection{Transformations}

Desugaring, simplification, trimming, and conversion to SSA.

\subsection{Queries}

Memory, jumps, arithmetic operators.

\subsection{Concolic Execution Redux}

Alternation. Compatibility. Soundness/Completeness. Efficiency.

\section{Evaluation}

\section{Related Work}

\section{Conclusions}

\bibliographystyle{plain}
\bibliography{refs}


\end{document}
